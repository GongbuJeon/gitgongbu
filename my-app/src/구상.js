//      모드

//  setstate로 설정



//      날짜 인풋값

// 날짜 선택하면 값 저장 / date
// 입력한 날짜값을 대조하기 / localstorage에서 값을 불러오고 날짜값이 input값과 일치한 값이 있을 경우, 
// 그에 해당하는 계획들[]의 시간값을 뽑아내기. 반복문의 배열에 대입. 



//      plan, do 버튼 

// 누르면 모달창 띄우기
// plan 버튼을 눌렀을 때 모드를 plan으로 바꾸기
// do 버튼을 눌렀을 때 모드를 do로 바꾸기
// 날짜값이 없을시 alert ('날짜를 설정해주세요.')



//      모달창(디자인)

// 제목, 시작시간, 종료시간, 상세메모, 해쉬태그 인풋값 / title, start, end, memo, hashtag
// x 버튼 만들고 누르면 모달창 display를 none으로 바꾸기
// 모달창이 켜졌을 때 모달창 밖의 화면을 어둡게 표현하기
// 모달창 바깥을 눌렀을 때도 모달창의 display가 none으로 되도록 하기



//      모달창(데이터)

// 입력 버튼 누르면 값을 저장하기 + 블럭으로 표현하기
// 입력 버튼을 누르고 난 후 끄트머리에 값 초기화하기(''로 만들기)



//      블럭

// 전체 div == plan div, do div 만들기 / width는 각각 50%, height는 100%
// 전체 div를 가운데로 조정
// 전체 div의 세로 길이를 일단 정하기 (px?)
// 높이를 24*60 = 1440등분하여 시간값은 60배로 곱하고 비율로 쪼개기 (시간의 차이값)
// 마진탑으로 시작시간의 표현을 설정

// 반복문을 어떻게 구성할 것인가
// [배열].map((a, i))



//      데이터의 형식
// 하나의 계획 : {제목 : 입력값, 시작시간 : 입력값, ...등등}
// 계획들(plan & do) : [ {제목 : 입력값, 시작시간 : 입력값, ...등등}, {제목 : 입력값, 시작시간 : 입력값, ...등등} ] / 배열
// 하루치 : { id : '날짜' , task : [ {제목 : 입력값, 시작시간 : 입력값, ...등등}, {제목 : 입력값, 시작시간 : 입력값, ...등등} ] } / 오브젝트
// task[0].시작시간, task[0].무슨무슨시간.  task 자체가 배열 array.length
// task.map((a, i)) => {
//    return ( margintop의 배열, height의 배열 )
//      == return ( 변수1 = [task[i].박스높이], 변수2 = [task[i].박스마진] )
// }


// boxheight , margin 
// id plan do 의 형식으로 object
// let days = []  밑에 로컬스토리지 불러오기
// for 반복문 써서 찾기